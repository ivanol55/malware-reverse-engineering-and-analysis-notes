# Static analysis techniques: the common procedures
In this section we'll focus into having a better understanding of how to identify malware samples, generate hashes, and extract signs may aid us during analysis. We'll look at online analysis sandboxing tools and scanners, the PE format and how it's used in malware analysis, obfuscation and basic malware detection methods, and how to collect samples and write YARA rules to detect them in the future.

## Introduction to static analysis
Throughout these notes you'll notice that we refer to the files we investigate as samples, not malware. The reason is, we need to do our analysis and research first to decide if a file is really malicious or just a false positive benign file. The first thing we do when we get a sample is to analyze it and get as much information as possible without running it. Don't execute the sample without some prior knowledge. This step of analyzing a sample before executing it is what we refer to as static analysis.

As we discussed in the previous section, static analysis can be further divided into the basic and advanced approaches. In the basic analysis we run various techniques and methods, but none of them involve looking at the sample's code, if available, or its assembly instructions after disassembly. An example of basic static analysis is looking at file metadata or other information embedded in it that could help us. Then, advanced static analysis goes a step further, where we examine the source code (or what we got from decompiling) of the sample.

We can divide the basic static analysis methodology into four phases:
1. File identification and classification
2. Scanning
3. File format analysis
4. Obfuscation identification

Let's go into further detail for each one of these.

### File identification and classification
File identification is the process of identifying the file type and obtaining a unique signature of the sample we're analyzing. We can think of this as the unique identifier of that sample. We can then share this identifier with other researchers so, if they see it, they know it's the same sample, without the need of running the analysis themselves again. Classifying a sample can help us understand if it belongs to a well-known malware family that's already been researched, thus providing us with a lot of supporting information for our work.

### Scanning
The approaches we use during file identification and classification will help us build basic detection methods and indicators of compromise. We can check if the hash of a file matches so we can trigger a future alert rule in case we see this sample appear in our environment again.

### File format analysis
We can identify files with several methods, like their file type (portable executable, pdf, docx), file hashes, or strings embedded within the file. All computer files fall under two different categories, they can be either ASCII plaintext files or structured binary files.

The first ones are the simplest form of a file since they do not contain any structured data, and are just plain text containers that we can read with any text editor. Note that files following notation standards, like HTML or XML, also count as plaintext files.

The files that don't fall under that category are considered binary files or structured files, since they contain a binary data structure. Every binary has its own structure to represent its content and has to be read a certain way. This structure helps us identify them, as they have file headers that identify their file format to help us read them properly.

### Obfuscation identification
Knowing how to identify different file formats will be important, because samples aren't always executables. Sometimes it's a DOCX file with embedded code, or an executable wrapped inside of a JPEG image. This identification can be done either manually or by using common tooling as support. An example of a lot of file signatures can be found in the [file sigs library](https://www.garykessler.net/library/file_sigs.html). A very good tool to keep in mind is the linux `file` command, which will read the file headers and return their known file format.

Remember not to trust file extensions, as these can be easily changed without affecting internal data structures. An executable named picture.jpeg is still an executable. It is not uncommon for malware to hide as a benign file format as a method of detection evasion. The file icon even be embedded into the application so the executable has a pdf icon. We can check this with the program [Resource Hacker](http://www.angusj.com/resourcehacker/).

## Hashes
Our next step is classifying the sample we are dealing with and determine if it is already known by the malware research community. We may be able to determine if this sample is related to a specific group, malware famly or threat actor with this step. One of the ways we do this is with the sample's hash.

THe hash is the result of a mathematical function that calculates a fixed-length string from the data in the sample. The same sample always produces the same hash. As such, we can use it to look for the signature in malware databases like VirusTotal.

There are many hashing functions used in malware analysis, but mostly we'll see md5, SHA-1 and SHA-256. Others we may see include fuzzyhash, import hash and section hash. We can create these hashes with many tools, CLI or GUI. CLI tools like sha256sum or md5sum are usual examples, while we have Nirsoft's HashMyFiles on the GUI side.

When we get a sample, we should always check its hashes against a sample database, to see if it has already been analyzed. If it has, we'll take a look at what artifacts does it leave behind, what to look for, and what we need to look for to confirm we've cleaned a system infected with this sample. We can also use this hash to look for that executable in other systems, using it as what we call an indicator of compromise or IOC.

A thing to keep in mind is, if we change a single bit of a file, we get an entirely different hash value. This means that the sample may modify itself for a certain target, without affecting its main functionality, which would break hash-based detection. Hashes are a simple detection method, but is easily circumvented. This capability is known as polymorphism.

To counteract this we make use of fuzzy hashing. This is a technique where we check how similar two files are in a percentage representation. So even if a hash is completely different, if we change one bit, we are 99% sure this is the same sample thanks to fuzzy hash checking. THis works by running hashing functions over segments of the file, then doing some math calculations over these values. This require us to compare two different samples against each other. to see how similar they are. A good CLI tool for this is SSDEEP.

## Strings
In computers we consider strings a data type, simply a sequence of characters, like someone's name or address are string values. Every file has strings in it, and we have to deal with them in all code. In most programming languages strings are implemented using arrays of characters, but can be implemented other ways, like records that end in an escape sequence (usually 00, a null-terminator).

As malware analysts we can greatly benefit from the extracted strings from a sample, where we can find data stored inside it such as:
- Messages the sample uses or displays
- Functions being referenced
- Code sections used by the sample
- IP addresses or domain names
- Error handling messages used
- Names or keywords we can use to identify the sample

Again, for this extraction we make great use of specialized tools, either CLI (strings, bstrings) or GUI (BinText, StringSifter, FLOSS)

### String types
All data inside a file is a set of strings, however, not all strings are printable. Printable strings are sets of characters that can be read and seen by humans, like letters or numbers. Non-printable strings can be, for example control characters (\n for newline, which is inserted when you press enter on your keyboard). They exist in text files, but we can't see them without a hexadecimal editor (where we'd see \x0A for \n)

### ASCII strings
Files use strings to represent, store, define or refer to data. The two main encodings for characters in strings are ASCII and Unicode. Ascii strings use 7 bits, which only allows us to represent 128 characters. However computers implement it with 1-byte chunks, letting us use 256 different character representations.

### Unicode strings
Unicode strings use a different encoding mechanism with longer byte sequences, and should be read differently. We should check for these different file encodings, but the most frequent universal one is UTF-8

## Scanners and sandboxes
A scanner is a piece of software that can check a file and decide wether it's benign or malicious. An example of this would be an antivirus. Scanners can be running in your computer, at a network level, or hosted by a separate vendor. Therefore, we have separations of online and offline scanners. We need to make sure to keep offline scanners updated as well.

Good examples of offline scanners would be ClamAV or Malwarebytes, while VirusTotal and HybridAnalysis are pretty established online tools for scanning samples.

We should remember to be wary of what samples we upload to online scanners like VirusTotal. That is, because the threat actor that planted the potential malware could be monitoring VirusTotal for the sample hashes, and if they find out they were detected, these attackers could change tactics or become destructive. Always start with offline scanners and sandboxes.

Sanboxes arre pieces of software that will run an isolated environment where our potentially harmful program can run without a risk of attacking the rest of our network. Threat mitigation while we investigate is very important. An example is a properly set-up virtual machine, although we have purpose-built software for this, like Cuckoo, Anlyz, any.run, Falcon Sandbox or ActivityComodo Valkyrie.

## File format analysis
When preparing to be a malware analysit, one of the most important topics to get familiar with is understanding the Portable Executable format. We focus on windows malware here, so we dedicate this section and our analysis efforts in these notes to the PE file format. 

There are several executable file formats that we can execute in Windows, some directly (like .exe or .scr files), while others such as .dll require other programs or services to run them. The program type is defined at compile time.

We have gone over the PE file format [earlier in these notes](https://github.com/ivanol55/malware-reverse-engineering-and-analysis-notes/blob/main/the-necessary-theory/4-vas-rvas-and-offsets/). Let's add some detail to some of the points made in that introduction.

### Library inclusion
As we mentioned, to make interaction with the operating system easier, programs make use of libraries, like the Windows libraries stored as DLLs. These libraries can be included in our program by the Linker at compile time. There are two variants: static and dynamic linking. 

The first one will copy the libraries into the final executable at compile time, and can be implicit (libraries are stored in a section of the program and loaded at runtime), or explicit (The developer calls the libraries from the code, and these are not loaded unless called).

Dynamic linking, however, does not embed the library code into the executable, but loads them from the operating system as required, which saves memory and file size.

This means that static linking is faster but the resulting files are bigger, not easily maintained and use up more memory. In the reverse scenario, dynamic linking programs are slower, but their executables are smaller, easier to maintain and use less memory. 

## Difference between 32-bit and 63-bit executable files
It is true that there is a difference between 32-bit and 64-bit compiled executables, but it's less of a difference than we tend to expect. Certain headers change, like indicating being able to handle more than 2GB of address space, or having different memory offset values which affects the null filler blocks and where does your program loaded memory start.

## How binary packing mechanisms can impact your initial assessment
Packing is a technique used by attackers to make your analysis of a binary a bit more difficult. Packers essentially compress and obfuscate analysis of a certain binary, where our usual initial assessment of checking for strings and sections is made difficult by wrapping this protection tool around the packed binary. UPX is an example packer. 

For example, when UPX packs a binary, the .text section is pointed to UPX0, and most sections are compressed into UPX0 and UPX1 sections, and analysis tools report "uninitialized data" instead of "code", because they don't detect the standard code section with its usual name. Other indicators are section sizes of the uninitialized program being 0 bytes, since they are empty and will be populated on execution time. The packer also prevents us from reading most of the strings data.

The wrapper that is generated by the packer hides all of the program information so the static analysis is harder. the unpacker is included with the code as well, and some programs like CFF Explorer can use that tool to unpack the code properly.
