# The necessary theory: Processes and threads
## Introduction
Now that we have a deeper understanding of CPU basics like memory allocation, manipulation, access and registers, During this section we'll discuss in depth about:
- **Functions**
- **Threads**, **processes** and the differences between them
- The **stack** and **stack frames**
- **Calling conventions**

## Functions
All modern software is actually just a set of smaller **sub-programs**, or **functions**. We can also call functions within a function if a process needs to be further broken down (usually called **sub-routines**). Each function is **dedicated to a specific operation** and either returns a value to the function that called it, or not. Likewise, a function might require a **parameter** or a set of parameters as input. Of course, this depends on the needs of the tasks executed inside of that function.

There are several reasons to break down a program into several sub-programs:
- Makes **understanding** and **maintaining** the code much easier
- In case of a **bug**, it's much easier to identify the moving parts that might affect it
- It makes it easier to **reuse** code or functions in different environments, making your codebase smaller

### The function memory reference
It is clear that when a function is called, something changes in the execution flow of the running program. Instructions in memory are executed one after another, and as we noted, the instruction pointer **always points to the memory location of the next instruction** to be executed. 

So, when a program needs to call a function and transfer execution flow to that function, the program needs a way to **remember where execution left off**. This is required in order for the program to continue once the function is complete so it can **go back to where it was** in execution after the function pointer. That called function may also need a set of parameters passed in order to operate, and we might want to store some register values to retrieve them once the function is done.

This is where the **procedure stack** comes into play - also known as the **stack**.

### The procedure stack
The **stack** is a **reserved memory area** inside a specific segment called the Stack segment, referenced in the SS register (as in Stack Segment register) we learned about in the previous section. The term **reserved** is used in this case in order to indicate its special use during the execution of a program.

## Processes and threads
Each thread executing inside a process has **its own stack**. This means if a process has five threads, then **there is a stack assigned for each one** - five stacks in total. At this point this might not make sense yet, but it will upon further explaining.

In order to distinguish processes from threads, think about the process as a **container**, and a thread as **something inside this container**. When you execute an application, the OS creates a process which is identified by a virtual address space in memory where all its needed modules are mapped, The OS also creates at least one thread that's ready for execution.

In fact, every process has its own virtual address space, but multiple threads inside the same process share the same virtual address space - the one of the process they belong to.

On the other hand, the term thread can indicate the **time-slice** assigned by the processor to that specific process in order to execute a portion of instructions inside it. In other words, in a single-processor system, only one thread can be executed at a time, but on a multi-processor or multi-core system it is possible to have **as many threads running simultaneously as the number of cores**.

This depends on the way the operating system is using the available resources. In other words, **the OS assigns various threads to the available processors**, in order to actually take advantage of the multi-thread execution capacity of having multiple processors.

A single-core processor is limited to doing a single task at a time, but we can run several tasks in an operating system. We are not limited to running as many tasks as we have cores, this is thanks to **multi-tasking**, where each process is **scheduled** a certain execution time in a queue. The illusion of running more than one process at a time is called **multitasking**, whereas actually running them simultaneously is **multithreading**.

## Calling functions
As we already mentioned, some functions might require one or more parameters. **A paraemter is a specific type of variable**. it can be a signed or unsigned **integer**, a **pointer** to an array, a **string**, a single **character**, etc. When a function we're about to call requires one or more parameters, these parameters are placed in the **stack** before entering that function.

### Storing function parameters
The 2 main instructions used for inserting and extracting values from the stack are `PUSH` and `POP`. **The first one places data** on top of the stack, and **the second one removes the value** from the top of the stack. Due to how this operates, we call it a **LIFO** (Last in, first out) data structure.

What happens internally is that when an item is placed on the top of the stack, the **ESP** register that keeps track of the top of the stack item, is **decremented** in order to point to the new item. During this, we'll assume our stack width is 32 bits.

This way, if we have four 32-bit items in our stack, they are numbered from the maximum bit of the stack and down. So if we add a fifth item to our stack, ESP is **reduced** by 32 bits to point to the new top item in our stack (the item now closest to bit 0 of the stack size). Likewise, when we remove an item from the stack, we **add** 32 to the value of ESP.

Once all required parameters are pushed to the stack, the program redirects the **EIP** or **program counter** to the start of the called function. At the same time, it needs to keep track of the address of the next instruction to execute after returning from that function. This is done by the `CALL` instruction.

### The CALL and RET instructions
The `CALL` assembly instruction is used to prepare function calling on your code. When this instruction is executed, the processor **pushes the return memory address** (called the **return-instruction pointer**) onto the stack, then loads the address of the entry point of the target function in the EIP register to start the execution of that function. The corresponding instruction to exit a function is called `RET`.

When the `RET` instruction is called, the processor **pops the address from the top of the stack to the EIP register** and resumes execution in the instruction located after the function call. This function is sometimes called with a value, an integer, which indicates the **number of bytes that should be purged from the stack** before exiting.

## Stack frames
As mentioned at the beginning of this section, applications are comprised of a set of functions, and each of these functions may `CALL` other subroutines, and in addition these functions may have needed variables and parameters. This means each function needs to be able to **remember what memory address to come back to**, and have their own space to store their parameters.

This separation for each function is achieved by splitting the stack into what we call **stack frames**. Each stack frame holds **just the necessary information** for the caller function.

Every time we enter a function, a stack frame is created through the **function prologue**. This is a set of instructions that allocate the necessary memory area for that specific function inside the stack, and it is the first thing done every time we enter a function.

Just after the function prologue we very often notice that some general-purpose registers are pushed onto the stack. This happens because we might want to use these registers during execution of the function, but we still need the initial values once the function is completed, so this stack frame is used as a **temporary storage area**.

Keep in mind that the memory size allocated for the stack by the operating system is **fixed**. This means we cannot just keep pushing values onto the stack indefinitely, and is one of the reasons why we **clean** the stack at the end of a function.

Once a function is finished, we need to **re-balance the stack**, and "free" the memory allocated for that stack frame, restoring the values on the **ESP** and **EBP** registers. This is done by the function **epilogue**, a set of instructions used to **clean up the stack before we exit** the function. If we want to keep some values from the function, like the general-purpose registers, we need to pop them out before the function epilogue.

### Function execution example
Here's an example of an executed function with its **prologue** and **epilogue**:
```
push ebp        # Get the base pointer (start address of the current stack frame) to the stack to save it
mov ebp,esp     # Copy the value of the stack pointer to the base pointer
sub esp,10h     # Allocate 10h (16 decimal in hex notation) bytes of space for the current stack frame

push eax        # We might want to save the values of general-purpose registers
push ebx        # We might want to save the values of general-purpose registers

add eax,ebx     # Start of function body
xor eax,ebx
sub ebx,eax     # End of function body

pop ebx         # Restore EBX (Remember, last in first out)
pop eax         # Restore EAX (is now the top of stack, as EBX is restored)

mov esp,ebp     # Start function epilogue, the pointer is set back where we started with (copying the backup stack pointer to the real stack pointer), which clears memory allocation
pop ebp         # Restore the caller's base pointer
ret             # End function
```

## Calling conventions
The term **calling conventions** refers to the way the parameters necessary for a function are pushed onto the stack in order and the way the stack is re-balanced. This occurs inside the function or from the function that called it. The most common calling conventions are `__cdecl`, `__stdcall` and `__fastcall`.

### Types of calling conventions
In the first two calling convention types, parameters are **pushed** onto the stack in **reverse** order. In other words if we have a function which accepts 2 parameters, for example `myFunction(int a, int b)`, then calling this function will be assembled as the following:
```
push b
push a
call myFunction
```

The difference between the first two calling conventions is that `__stdcall` cleans up the stack by popping the parameters from the stack inside the function itself, but the `__cdecl` calling convention needs to add the cleanup code to pop the arguments from the stack **after** the call to the function. In this case, then, the caller is responsible for the cleanup. This means `__stdcall`-style programs are **smaller**, as we do not need to repeat cleanup code every time the function is called.

Finally, `__fastcall` runs the stack cleanup inside the **callee** (the called function), but some parameters, instead of being passed via the stack before entering the function, are passed through one or more **general purpose registers**. Because of this, this method makes less use of the stack.

### Windows APIs
Windows APIs (**Win32 API functions**) use `__stdcall` calling conventions. This is due to the size of the code being smaller, and also because the amount of necessary memory for the arguments of each call is predefined, so the function knows how much space to clean up before exiting.

## Reading EIP: a simple trick
As mentioned in the first section, we don't have direct access to reading the EIP register, but we might want to know the address of the next instruction to be executed. What we can do is create a function that returns, in **EAX** (or another registar that you can directly access) the value of **EIP**. Here's an example:
```
GetEIP proc
mov eax, dword ptr ss:[esp]
ret
GetEIP endp
```

What we do in this example is to call the `GetEIP` function, which will move the return address into **EAX**, which is the next instruction after the "call GetEIP" instruction. So we know what the **EIP** address is after our execution getting it from the **ESP** register (the stack address pointer with the return address, which is the next instruction's memory location for when we exit a function) from inside **SS** (our stack segment that points to our current stack)

This technique is widely used by "relocatable code", which is assembly code you can **inject** anywhere into source or in memory, just like **shellcode** is used by exploits and **code injection** works in malware in many cases.
