# The necessary theory: Heaps, handles and exceptions
## Introduction
This final introduction secton aims to briefly discuss the necessary theoretical concepts of **heaps**, **handles** and **exceptions**, as well as some basic **Windows Ring3 Internal structures**. We'll also have a broad look at **Windows API**s. Finally we'll go through the most **common reversing tools** used today for software reverse engineering. Some of the concepts we'll discuss will be tightly integrated with a very important part of the process: the **anti-reversing tricks** employed by software developers. We'll cover these later on.

## Heaps
When we talk about **heaps**, we are referring to **memory areas dynamically allocated at runtime**, used to store data that doesn't have a fixed size or data that can't fit inside the stack. In order to grasp this concept, let's look at an example. Assume that someone is creating an application for file manipulation and because of its organization, the entire file needs to be **loaded into memory** somewhere.

Of course, the developer doesn't know the size of every possible file that will pass through the program, but initializing a huge array that could fit any possible file is also not an option. This application would be using much more phyisical memory than necessary that it may never actually use, which would greatly impact performance. 

Because of this, we need **dynamic memory allocation** in order to be able to fit the selected file into memory, regardless of size, while at the same time not wasting any physical memory when it's not necessary. That is the reason why we need memory heaps.

## Handles
Handles can be considered **references** to varous resources, and they are used by the operating system in order to **control access** to these resources (**reading** and **writing**, for example). A simple example for handles in windows has to do with file manipulation. 

In order to access a file, you first need to **create a handle for that file** using a Windows API, such as the `CreateFile` API that returns the handle object, in this case a number to identify it and the requested access rights to it.

## Exceptions
An **exception** is a specific type of **event** that occurs during the execution of an application. Exceptions are normally associated with specific **exception handlers**, which are code blocks dedicated to handle that type of event correctly.

Since exceptions can also be caused by programming errors, it is important to have an exception handler that will **prevent the application from crashing unexpectedly**. There are two types of exceptions to handle:
- **Hardware**
- **Software**

### Exception types
Hardware exceptions are normally caused by the execution of a **bad sequence of instructions** such as a division by zero or an attempt to access either an invalid memory location or a location that the program doesn't have the necessary access rights to. **Hardware exceptions are initiated by the CPU**. The Windows OS is able to recognize hadrware exceptions and map them to a list of predefined constants or **exception codes**.

On the other hand, **software** exceptions are **generated by the application** (or the operating system itself) and can be used in order to flag certain conditions with **user defined exception codes**. 

### Handling Windows exceptions
Windows implements its own mechanism to handle exceptions which is called **Structured Exception Handling**. SEH gives the application the ability to handle both hardware and software exceptions in the same manner and allows the application full control over any exceptions raised during its execution.

### Exception handling against reverse engineering
Exception handling is commonly used as an **anti-reversing tool**, as the exception redirects the application flow and throws off the analysis tool.

## Basic Ring3 internal structures
Let's have a look at two **Userland** (ring3) structures which keep very important information regarding the running process and its threads under execution. 

The first one is  `THREAD_ENVIRONMENT_BLOCK` (TEB). This structure stores information such as:
- The **address** of the top and bottom of the current thread's **stack**
- The **thread identifier**
- The **identifier of the process** the thread belongs to
- The **code of the last error** that occurred during the thread execution
- The address of the **Thread Local Storage** (TLS)
- The address of the `PROCESS_ENVIRONMENT_BLOCK` (PEB)

The second structure is `PROCESS_ENVIRONMENT_BLOCK` (PEB), which stores, among many other elements:
- the **image base** of the process
- The **address of the loader data structure** (`PEB_LDR_DATA`, containing pointers to lists regarding the modules loaded by the process)
- The `NtGlobalFlag` value
- The major and minor **versions of the Windows OS**
- The **number of processors** available
- The `BeingDebugged` flag

Some of the information inside the PEB can be used for **debugger detection**, such as `NtGlobalFlag`, and the `BeingDebugged` flag.

Another very important structure is `CONTEXT`, which the system uses to **keep track of all the necessary CPU state information** for a specific thread under execution during internal operations, like **storing the registers** that a thread would need to continue normal operation in case an event like an exception occurs.

## Windows APIs
Windows APIs are **ring3 operating system functions**. Their use is **well-documented** and the **parameters** they receive and their purpose is clear so that they can be used by programmers in order to take advantage of the various functionalities of the operating system and safely communicate with **kernel functions**. They are the **communication path** from the application to the underlying operating system.

Windows APIs are separated by functional categories:
- **Administration** and **management**
- **Diagnostics**
- Graphics and **multimedia**
- **Networking**
- System **services**
- Windows **User Interface**

## Types of reversing tools
During the reverse engineering process, various tools can be used for different purposes, for example:
- **Hex editors**, which read the contents of any file type and show the **byte groups** representing the data in **hexadecimal**. Even though more advanced tools exist, they are **still considered powerful for non-executable files**
- **Decompilers**, which attempt to **convert low-level code** (such as machine code) into a **higher-level language** that is much easier to understand. Mostly used for programs that run under java or .NET virtual mnachines, due to the code not being binary, but an intermediate state, which makes it possible to decompile back into an **indication** of the source code.
- **Disassemblers**, useful tools used to **translate binary into human-readable assembly** instructions. This only offers static analysis, and are usually incorporated within debuggers.
- **Debuggers**, incorporating hex editing and disassembling capabilities, as well as execution flow control in real time, allow for a very **powerful testing suite** when reverse engineering a program. They can be **kernel mode** or **user mode**, the first one being more powerful due to having **direct memory access** and manipulation and thus are **undetectable by most of the anti-reversing techniques**.
- **System monitoring tools**, used when we want to monitor various actions of the process under analysis, like its **access to files** and **windows registry keys**.
- **Windows API monitoring tools**, which hook Windows APIs used by the process under examination. They can be really useful to have a **quick overview of the Windows APIs used** by the program.
