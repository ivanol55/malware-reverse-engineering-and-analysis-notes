# The necessary theory: Virtual Addresses, Relative Virtual Addresses and offsets
## Introduction
In this final introductory section we will discuss about **virtual addresses**, **relative virtual addresses** and **memory offsets**, as well as some basic information about the **Portable Executable file format**, which describes the basic structure of all Windows executable files.

## VAs, RVAs and offsets
Before proceeding with the technical discussion, let's summarize these three concepts. Understanding how these concepts are connected and how to calculate one from another is critical for reverse engineering, not just in these notes, but in every reversing challenge you find in your career.

**Applications do not directly access physical memory**, only virtual memory. The memory addresses referenced bt an application are **Virtual Addresses** (VAs). Virtualizing access to memory provides flexibility in the way applications use available physical memory. An application doesn't have to occupy a contiguous space of physical memory. Instead, it can be **broken down into parts** without the application needed to handle that.

The OS provides the **illusion** to the application that it occupies a contiguous memory area by translating virtual addresses to physical memory addresses. A relative virtual address is the **difference between two VAs** and refers to the highest one.

On the other hand, when we talk about offsets, we usually refer either to **physical memory**, a **physical file** on disk, or other general cases where we treat data as **raw data**, without worrying about differences in the internal alignment of this data on memory against the one on the disk. The offset is the difference between the locations of 2 bytes, for example inside a file, starting from the beginning of the file.

### Why do we need all this information?
The answer is strainghtforward. Very often during the reversing process of an application, you will have to do some code modifications for testing porposes for other reasons, such as permanently de-activating an anti-reversing trick. Of course, patching the code in memory at runtime is a **temporary solution** that lasts only as long as the application is running. 

In order to make this change permanent, it would be necessary to **patch the phyisical file** itself, and for that, it's necessary that you can calculate the offsets of the bytes you want to modify in the file on disk.

Even though you'll not usually have to manually calculate the offset of a byte inside the file itself using its VA or RVA (because your debugger will do it automatically), it is extremely important to **keep these concepts straight in your mind**, since you never know when you might need them.

## Overview of the Portable Executable file format
Since these notes target Windows applications, let's demonstrate the **basic structure of the PE file format** starting at the beginning of the file. There are minor differences between 32-bit and 64-bit application, but for simplicity, we'll focus on 32-bit applications here.

### The MS-DOS header
Every PE file starts with a **small MS-DOS executable**. This was required in the early days of windows, before it became a popular OS. This small stub executable would, at a minimum, display a message stating what Windows OS was required to run the application. The first bytes of the PE file are the **traditional MS-DOS header**, also called `IMAGE_DOS_HEADER`.

The two important values in this header are:
- `e_magic`, a 16-bit value which must be `0x5A4D` (MZ in ascii), also called `IMAGE_DOS_SIGNATURE`
- `e_lfanew`, at offset 3Ch which contains the file offset of the start of the PE header, also called the `IMAGE_NT_HEADERS` structure.

### `IMAGE_NT_HEADERS` structure
The PE header is actually formed by combining together a few other **structures** that we are going to discuss in further detail. It is a structure defined as follows:
```
typedef struct _IMAGE_NT_HEADERS {
    DWORD                   Signature;
    IMAGE_FILE_HEADER       FileHeader;
    IMAGE_OPTIONAL_HEADER   OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
```

Its signature is `50450000h` (`PE\0\0` in ascii). The passed values are other structs with the following formats:
- `IMAGE_FILE_HEADER`, containing information about executable characteristics (**target CPU architecture**, number of **sections**). It also contains a member with the size value of the `IMAGE_OPTIONAL_HEADER` structure called **SizeOfOptionalHeader** (must be set to `E0h`), and **Characteristics**, which defines some characteristics such as the type of executable file (`.exe` or `.dll`)
```
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```
- `IMAGE_OPTIONAL_HEADER`, A **non-optional** structure passed to the `IMAGE_FILE_HEADER`, contains the additional information for the file, like the **Magic number** defining if it's a 32 or 64-bit module, the **Address of the module entrypoint** to know what instruction to execute first, **pointers** to the beginning of the code and data, and the **memory size** when the module is loaded. Ends with a pointer to the `IMAGE_DATA_DIRECTORY` structure beginning address. The structure is the following:
```
typedef struct _IMAGE_OPTIONAL_HEADER {
    WORD                    Magic;
    BYTE                    MajorLinkerVersion;
    BYTE                    MinorLinkerVersion;
    DWORD                   SizeOfCode;
    DWORD                   SizeOfInitializedData;
    DWORD                   SizeOfUninitializedData;
    DWORD                   AddressOfEntryPoint;
    DWORD                   BaseOfCode;
    DWORD                   BaseOfData;
    DWORD                   ImageBase;
    DWORD                   SectionAlignment;
    DWORD                   FileAlignment;
    WORD                    MajorOperatingSystemVersion;
    WORD                    MinorOperatingSystemVersion;
    WORD                    MajorImageVersion;
    WORD                    MinorImageVersion;
    WORD                    MajorSubsystemVersion;
    WORD                    MinorSubsystemVersion;
    DWORD                   Win32VersionValue;
    DWORD                   SizeOfImage;
    DWORD                   SizeOfHeaders;
    DWORD                   CheckSum;
    WORD                    Subsystem;
    WORD                    Dllcharacteristics;
    DWORD                   SizeOfStackReserve;
    DWORD                   SizeOfStackCommit;
    DWORD                   SizeOfHeapReserve;
    DWORD                   SizeOfHeapCommit;
    DWORD                   LoaderFlags;
    DWORD                   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY    DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
```
- Finally we get to the `IMAGE_DATA_DIRECTORY` structure, for which each (16 of these by default) hold **RVAs** and sizes of specific data inside the PE image on runtime:
```
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

### The Section table
The section table is an array of `IMAGE_SECTION_HEADER` structures. Each structutre contains information about its associated section: **location**, **size**, and characteristics that describe **access permissions** within that section, like if wether the code in memory within that section is **writable**, **readable**, or if the code has **execution permissions**.

Tahe following is an example of an `IMAGE_SECTION_HEADER` structure for a section of the PE file. The section name can be at most 8 characters, so this member always occupies 8 bytes of memory.
```
004001A8 ASCII ".text"                 ;SECTION NAME
004001BO 92200000 DWORD 00002092h      ; VirtualSize = 2092h
004001B4 00100000 DWORD 00001000h      ; VirtualAddress = 1000h
004001B8 00220000 DWORD 00002200h      ; SizeOfRawData = 2200h
004001BC 00040000 DWORD 00000400h      ; PointerToRawData = 400h
004001C0 00000000 DWORD 00000000       ; PointerToRelocations = 0
004001C4 00000000 DWORD 00000000       ; PointerToLineNumbers = 0
004001C8 0000     WORD  0000           ; NumberOfRelocations = 0
004001CA 0000     WORD  0000           ; NumberOfLineNumbers = 0
004001CC 20000060 DWORD 60000020h      ; Characteristics = CODE EXECUTE | READ
```

Let's clear up the most important sections from this structure:
- `VirtualSize` is the size of the section in memory, without the padding for memory alignment
- `VirtualAddress` is the RVA of the section in memory. Using this and the VirtualSize information we can calculate the RVA of the next section, assuming that the memory alignment property is the default, plus padding of row data if needed
- `SizeOfRowData` is the real size of this section in the file. If this is the last section and we sum this value with the PointerToRawData value, the result is the size of the file itself.
- `PointerToRawData` is the offset where the raw data section starts in the file, so by adding this pointer to the size, we can get where the next section starts
- `Characteristics` indicates the memory access rights for that section (R, RW, RWE, etc)

Some common section names in executables are:
- `.text`, which is usually the first sectio containing the executable code of the application. Inside this section is also the entry point, the address of the first instruction that will run when executed. An executable can have more than one section with executable code
- `data` contains the initialized data of an application, such as the strings
- `.rdata` or `.idata` usually contain the import table, which is the table that list the Winows APIs used by the application, alongside their associated DLLs so the windows loader knows what API addresses it needs to retrieve
- `.rsrc` is a common name for the resource container section, which contains things like images for the application's UI

These names are just **conventions** and the author can modify them, and it is not implied that they will always be used with the same name or with the same purpose. **Each section has its own memory characteristics** to control access permissions, for example `.text` usually has **read** and **execute**, or `.rsrc` is **read-only**.

## Memory and file alignment
As we mentioned earlier, an executable file is usually comprised of several sections that serve different purposes. These sections can contain **executable code** that will run our application, or simply **store variables or resources** that our application will read

The alignment of the sections of the physical file is usually **different** from its image in loaded memory by the time it runs. The typical alignment for file sections is `0x200`, while the in-memory default is `0x1000`. This is just a default and **can be changed** if necessary.

These values indicate the size of a section in the file or in memory must be a multiple of. These are stored inside the `IMAGE_OPTIONAL_HEADER` structure we mentioned earlier, occupying two 32-bit members as `FileAlignment` and `SectionAlignment`.

The reason behind these default values is that we use the file alignment to ensure that the beginning of each section in the file will **correspond to the beginning of a disk sector**, which is usually `0x200` (`512` decimal) bytes. The missing bytes of a section, wether on disk or when loaded into memory, will be **padded with zeros** to fid the section size. If the code in `.text` is `0x1050` bytes, the disk storage linker would pad it with zeros to the closest multiple, in this case `0x1200`. when it's loaded into memory, as per the memory alignment, it would be padded to `0x2000`.