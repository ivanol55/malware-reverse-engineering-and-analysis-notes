# Writing assembly: a crash course
Assembly is a low-level programming language, low-level here meaning it's closer to the code executed by the CPU. It is non-portable and with almost no abstractions. It is what languages like C are compiled to. It is the intermediate point between machine code and almost all higher-level languages. Some languages like Java might use other intermediate steps like the virtual machine to convert that code further to support multi-platform builds. We will use C++ as an example, because it has a good, clear conversion to assembly code and better support for disassembly tools.

Some important concepts to remember are that every machine code instruction is represented by a single assembly instruction. Every machine manufacturer uses their implementation of assembly, which can vary, so platform is imporant for a lot of instructions. Every instruction that directly maps to a machine operand. The assembly language does not provide abstractions like classes, objects, reusable functions, or control statements and loops. THis can all be reproduced in asssembly, but with a lot of boilerplate code.

## Why do we need Assembly?
Programs are usually made in higher-level languages like Java, but as we will not have the source code available, we can only use what we get out of the binary, we need to deeply understand some assembly to be able to work on reverse engineering.

Assembly was originally used a long time ago to create very optimized, performance-focused programs, but with modern compilers poacking intelligent optimizer, the use for this low-level language has dropped.

We may still need to learn assembly for some very near-the-hardware tasks:
- Writing drivers for operating systems
- Reverse engineering a program to gind bulnerabilities or find an executable's purpose

We read this code by targeting the running process and looking into its executable bytecode as assembly instructions. THis will greatly help us understand the program's behavior at a CPU level, and allow us to bring the code to our desired state during analysis.

## CPU Architecture
We already covered how a CPU works in-depth in the course introduction, but let's expand some of the details. Because assembly language is a type of machine code that can be understood by humans, the first step is to understand the components of the CPU:
- the Control Unit manages execution and data flow for all other components. It fetches machine code instructions from the memory, decodes them into instructions, loads and saves data from registers, and tells other units to run operations
- Registers are memory stores used by various machine instructions. Almost all instructions refer to a register in one of their operands
- the Arithmetic and Logic Unit handles arithmetic and bitwise operations on integer values
- the Floating-point Unit handles arithmetic operations for floating point values

THose are the basics, but modern CPU's have a lot more components, like cache memory, or even an integrated graphics processing unit.

In 64-bit architecure we saw 32-bit registers, which still apply here. We can extend to a 64-bit register in 64-bit architecture, where we refer to the AX registers familiy as RAX for the entire 64-bit word. Same for the rest of the families, we just swap the R to the beginning ox the name. RBX, RCX, RDX, RDI...

Furthermore, 64-bit CPUs add new registers, R8 to R15, mostly used as helpers with no defined purpose.

## Assembly basics
In general, Assembly instructions are built with the following format:
```
[instruction] [destinatiom address, if applicable],[source address if applicable]
```

Anything after a semicolon is considered a comment. Here's some examples:
```
MOV RCX,20h ; Copy hex value 20 into RCX
INC EAX     ; Increase the value of EAX by one
INC EAX,3h  ; Syntax error, as INC only takes a target operand, not a source
```

### Instruction types
- General purpose instructions are available in all x84 and x64 CPUs
- x87 FPU instructions are floating point instructions available in almost all x64 CPUs
- MMX instructions are multimedia helpers available in almost all x64 CPUs
- Intel SHA extension instructions are SHA algorithm calculators, available on Intel Atom CPUs

### Execution speed and effects
Each instruction has its own use, size and speed. The size of an instruction varies on the given operands, as does the execution speed. But on modern CPU's, speed comparison is not feasible anymore. This is due to many factors on CPU architecture like branch prediction, out of scope for these notes. We will focus on instruction effects.

It is best to learn as many assembly instructions as possible for several reasons:
- Optimization add eax,1 and inc eax both will increase the EAX register by one, but we use INC because its machine code is smaller. But if we need to keep the Carry Flag state, then we use add, because it affects the CF and INC doesn't
- Obfuscation, as some instructions make it harder on reverse engineers to figure out the execution path of a process. Note that this obfuscation may greatly impact optimization

### Fundamental data types
The data types available also represent unsigned numeric values:
- Byte, one memory byte
- Word, 2 bytes
- Double words, 4 bytes
- Quad word, 8 bytes
- Double quad word, 16 bytes

### Floating-point data type
FLoating point values are stored fundamentally differently from other data types. As we fundamentally only have binary numbers, we need to separate into sign bit, 8 bit exponent for the whole number, and 23 bits precision for the the decimal or fraction part of the number.

General purpose instructions cannot deal with float values directly. A simple operation like incrementing a float value by one will require many lines of complicated code with general-purpose instructions like ADD, MOB, SHL, or SHR. To make this easier, we use FPU instructions.

FPU instructions use the floating point unit to ease these operations, like FADD to add values to a float, or FMUL to multiply the float by some number. FPU instructions can process four types of floats, that are either 16, 32, 64 or 80 bits in length.

### Using registers
Copying values from one register to another, from memory to register or vice versa, is called moving. Therefore, in assembly, when we move a value, we are copying from source to testination. The most frequently used instruction for this is MOV.

Registers are the fastest memory locations in the computer, because they are built inside of the CPU and are hihhly integrated. Because they are faster, it will be very convenient for operations to have values on registers, process them, then move them back into memory when we're done.

Registers themselves, as we mentioned in the introduction sectiuon, can be accessed with different names depending on the part we need. (RAX for the entire 64-bit register, EAX for the low 32-bit half). Moving values between registers and memory must be handled in identical sizes. Moving values into a part of a register will not affect the parts we haven't referenced.Here's an example:
```
mov rax,0x00000001  ;   RAX is now 0000 0001 0000 0000
mov eax,0x0fff      ;   RAX is now 0000 0001 0000 ffff
mov ah,0            ;   RAX is now 0000 0001 0000 00ff
```

### Mathematical operations
Registers can be used for mathematical operations through general purpose instructions, like:
- ADD, calculating the sum of destination and source operands and saving the result in the destination (operands can be registers, memory addresses or constants)
- SUB, which substracts the source from the destination and saves the result in the destination (operands can be registers, memory addresses or constants)
- MUL, which multiplies the provided operand with the number from an implicit register and saves it in RAX, EAX, AX or AL depending on source size in the low part, and RDX, EDX, DX or DL as the high part (depending on source size)
- DIV, which divides the provided operand in a similar way. It is important to note that MUL deals with unsigned values, while IMUL is for signed values. Both deal with integers, having FDIV for floats.

### Logical operations
We can also perform logical operations with instructions like AND, OR, XOR Aand NOT. Flags like the Zero Flag (ZF) are affected by the results of these instructions. In addition, the TEST instruction is used to perform a virtual AND operation and affects flag values without saving the result in the destination operand.

Logical instructions are very important as they are heavily used to control the execution path of the program. This is done using conditional jump instructions controlled by flags.

The XOR instruction specifically can be seen being used in some odd ways:
```
xor eax,eax
```

This compares the EAX register with itself, which always results in zero. It is similar to doing the following:
```
mov eax,0
```

The XOR instruction is an optimized use of assembly instructions. Converting the MOV instruction to machince doe consumes more vyes than converting the XOR instruction, and in older CPUs, XOR was faster than MOV.

### Bitwise operations
Bitwise operations are used to shift or rotate values of a register:
- SHL shifts bits to the left. Most-significant bits might be lost.
- SHR shifts bits to the right. Least-significant bits might be lost.
- ROL rotates bits to the left. Most-significant bits on the left are reinserted into the right.
- ROR rotates bits to the right. Least-significant bits on the right are reinserted into the left.

Here's some examples:
```
mov eax,0x1004      ; 0001 0000 0000 0100
shr ax,2            ; 0001 0000 0000 0001
ror eax,1           ; 1000 1000 0000 0000
shl ax,1            ; 1000 1000 0000 0000
shl eax,1           ; 0001 0000 0000 0000
```

### Control-Transfer instructions
To change the execution path and control flow of the program, Control-Transfer instructions are used. Using them is the only way to change the value of RIP, the execution path. Control-Transfer instructions split into two main categories:
- Unconditional, which change the execution path when encountered, like JMP, CALL, RET and INT
- Conditional, which change the path only if a condition is met. For example, JZ, JNZ, JE and LOOP

Every conditional jump instruction executes differently:
- JZ or JE if the Zero Flag is set
- JNZ if the Zero Flag is clear
- JCF checks for the Carry Flag

Here's an example that compares two registers and changes the execution path if both have the same value:
```
xor ebx,eax
jz 0x50000000   ; address of next line of code to go to if the XOR was equal
```

Here's a loop example that sums numbers from 12 to 1, and in the end, EBX is 78:
```
xor rax,rax
mov ecx,12

_summation_loop:
add eax,ecx

loop _summation_loop

mov ebx,eax
```

LOOP will keep jumping back to the loop source as long as ECX is not zero, decrementing ECX by one each time. We also used a label instead of a memory address, which makes maintaining the code easier. These can also be used with JUMP or CALL instructions.

Do not confuse labels with functions in higher level languages. They are not the same, but here we greatly benefit and depend on them.

#### the Interrupt instruction
the INT instruction is a very special instruction used to call kernel functions. These kernel calls are called interrupts. The program must fill in registers with specific values before calling them, which depends on the kernel call we're doing.

Because we're making system kernel calls, compatibility depends on what kernel we're running on.

#### Sub-routines
the CALL instruction is used similarly to JUMP to change execution path unconditionally. The power of the CALL instruction is that it saves the original value of the RIP register in the stack, and the RET instruction can take us back to where we were, the instruction that was coming right afer the original CALL.

A sub-routine is a virtual convention used to define the instructions starting from the first instruction where CALL points, and ending by RET. Assembly developers, and compilers on higher-level languages, are responsible for keeping tabs if each CALL has a corresponding RET.
